# -*- coding: utf-8 -*-

# Built-in imports
import os
import shutil
from xml.etree import ElementTree

# Custom imports
from xmlcli import XmlCli as cli
from xmlcli.common import utils
from xmlcli.common.logger import log
from xmlcli.common import uefi_nvar
from xmlcli.common import configurations

__author__ = "Gahan Saraiya"


def get_integer_value(number):
  return utils.get_integer_value(number, base=10)


class NvarDb(object):
  """Database to store Nvars and knobs"""
  def __init__(self):
    self.xml_dir = os.path.dirname(os.path.abspath(__file__))
    self.xml_location = os.path.join(self.xml_dir, "do_not_delete_or_modify.xml")
    self.xml_location_bak = "{}.bak".format(self.xml_location)
    self.make_xml_backup()
    self.database = {}
    self.xml_issue_found = False
    self.response_buffer_location = os.path.join(configurations.OUT_DIR, "NvarRespBuff.bin")
    self.interface = None
  # self.database = self.load_verified_xml(self.xml_location)

  def make_xml_backup(self):
    if os.path.exists(self.xml_location):
      shutil.copy2(self.xml_location, self.xml_location_bak)

  @staticmethod
  def get_response_buffer(xml_file, nvar_dict=None, operation="get", interface="winrwe"):
    print("Performing operation '{}' on xml: '{}' using interface: '{}'".format(operation, xml_file, interface))
    cli.clb._setCliAccess(interface)
    result = uefi_nvar.get_set_var(operation=operation, xml_file=xml_file, nvar_dict=nvar_dict, display_result=True)
    if result == 1:
      for nvar_key, value in nvar_dict.items():
        nvar_dict[nvar_key]["status"] = 0xe
        nvar_dict[nvar_key]["is_exist"] = False
      return nvar_dict
    if isinstance(result, dict):
      return result
    else:
      return {}

  def load_verified_xml(self, xml_file, interface="winrwe"):
    """Load Nvars from XML and verify it's existence on SUT,
    if valid interface is selected.
    No verification will be carried out if:
      - stub mode is passed as interface
      - empty/invalid nvar structure exist in xml

    :param xml_file: location of xml file
    :param interface: access interface to SUT
    :return:
    """
    nvar_dict = self.load_xml(xml_file=xml_file)  # nvar dict containing data of XML file read
    print(nvar_dict)
    if not nvar_dict:  # may be empty if no nvar or xml
      # In case of no xml or nvar exist
      log.debug("Empty XML passed (No Nvar structure exist on given xml: {})".format(self.xml_location))
      return nvar_dict
    else:
      if interface == "stub":
        # do not bother to verifying xml if working in stub (offline mode)
        return nvar_dict
      nvar_dict = self.get_response_buffer(xml_file=self.xml_location, nvar_dict=nvar_dict, operation="get", interface=interface)
      return nvar_dict

  @staticmethod
  def load_xml(xml_file):
    """Wrapper Class Method to `utils.load_nvar_xml()` method"""
    return utils.load_nvar_xml(xml_file=xml_file)

  def construct_xml(self, input_dict=None, get_operation=True):
    input_dict = self.database if not input_dict else input_dict
    root = ElementTree.Element("SYSTEM")
    comment = ElementTree.Comment("Generated by XmlCli")
    root.append(comment)
    for key, values in input_dict.items():
      # if values.get("is_deleted", False):
      # 	continue
      nvar_element = ElementTree.SubElement(root, "Nvar")
      nvar_element.attrib = {
        "name": values["name"],
        "guid": values["guid"],
        "attributes": values["attributes"],
        "size": hex(get_integer_value(values["next_offset"])),
        "operation": hex(get_integer_value(values.get("operation", "0x0" if get_operation else "0x1"))),
        "status": "0x00"  # should be updated after reading back the response
      }
      for knob, details in values.get("knobs", {}).items():
        knob_element = ElementTree.SubElement(nvar_element, "knob")
        knob_value = hex(get_integer_value(details["value"])) if details["knob_type"] != "string" else details["value"]
        knob_current_value = hex(get_integer_value(details["current_value"])) if details["current_value"] != "string" else details["current_value"]
        knob_element.attrib = {
          "name": details["name"],
          "setupType": details["knob_type"],
          "default": knob_value,
          "CurrentVal": knob_current_value,
          "size": hex(get_integer_value(details["size"])),
          "offset": hex(get_integer_value(details["offset"])),
          "description": details["description"],
        }
        if details["knob_type"] == "oneof":
          options = ElementTree.SubElement(knob_element, "options")
          for op in details.get("options", []):
            option = ElementTree.SubElement(options, "option")
            option.attrib = {
              "text": op.get("text"),
              "value": op.get("value")
            }
        elif details["knob_type"] == "string":
          knob_element.attrib.update({
            "minsize": hex(get_integer_value(details.get("min_characters"))),
            "maxsize": hex(get_integer_value(details.get("max_characters")))
          })
        elif details["knob_type"] == "numeric":
          knob_element.attrib.update({
            "min": hex(get_integer_value(details.get("min_value"))),
            "max": hex(get_integer_value(details.get("max_value")))
          })
    return root

  @staticmethod
  def xml_string(root_node):
    return ElementTree.tostring(root_node)

  def store_xml(self, root_node, xml_path=None, encoding="utf-8"):
    xml_path = self.xml_location if not xml_path else xml_path
    tree = ElementTree.ElementTree(root_node)
    tree.write(xml_path, encoding=encoding)
    return xml_path

  @property
  def all_data(self):
    return self.database

  def compute_occupied_space(self, nvar_key):
    knobs = self.database.get(nvar_key).get("knobs", {})
    occupied_space = 0
    for knob, knob_data in knobs.items():
      occupied_space += utils.get_integer_value(knob_data["size"])
    return occupied_space

  def get_free_space(self, nvar_key):
    size = get_integer_value(self.database[nvar_key]["size"])
    free_space = size - self.compute_occupied_space(nvar_key=nvar_key)
    return free_space

  def get_next_offset(self, nvar_key, size):
    current_offset = get_integer_value(self.database[nvar_key]["next_offset"])
    size = get_integer_value(size)
    return current_offset + size

  def create_nvar(self, data_dict):
    key = "{}_{}".format(data_dict["name"], data_dict["guid"])
    if key not in self.database:
      self.database[key] = data_dict
      self.database[key]["is_exist"] = False  # initialized size to zero
      self.database[key]["size"] = 0  # initialized size to zero
      self.database[key]["next_offset"] = 0
      self.database[key]["free_space"] = self.compute_occupied_space(nvar_key=key)
      self.database[key].setdefault("knobs", {})
      status = "success"
      message = "Nvar created successfully"
      extra_details = self.database[key]
    else:
      status = "error"
      message = "Key: {} already exist. Nvar data with given nvar name and guid is already exist".format(key)
      extra_details = self.database[key]
    return {
      "status": status,
      "message": message,
      "extra_details": extra_details
    }

  def search_nvar(self, key):
    search_result = self.database.get(key, None)
    print(search_result)
    if search_result is not None:
      result = {"status": "success", "message": "", "extra_details": search_result}
    else:
      result = {"status": "error", "message": "Could not find Nvar with key: {}".format(key)}
    return result

  def delete_nvar(self, key):
    if key in self.database:
      self.database[key]["size"] = 0
      self.database[key]["next_offset"] = 0
      self.database[key]["is_deleted"] = True
      result = {"status": "success", "message": "Nvar size changed to 0 to delete. (nvar key: {})".format(key), "extra_details": self.database[key]}
    else:
      result = {"status": "error", "message": "Could not delete Nvar with key: {}".format(key)}
    return result

  def create_knob(self, nvar_key, unique_id, data_dict):
    if nvar_key in self.database:
      print(">> ", self.get_free_space(nvar_key))
      if self.get_free_space(nvar_key) <= get_integer_value(data_dict["size"]) and self.database[nvar_key]["is_exist"]:  # Nvar created on SUT
        err_message = "Not enough space to create knob"
        print(err_message)
        return {"status": "error", "message": err_message}
      else:  # Nvar to be created and not exist on SUT
        nvar_size = get_integer_value(self.database[nvar_key]["size"])
        knob_size = get_integer_value(data_dict["size"])
        free_space = self.get_free_space(nvar_key)
        if not self.database[nvar_key]["is_exist"]:
          self.database[nvar_key]["size"] = nvar_size + knob_size

        self.database[nvar_key]["free_space"] = free_space

        if data_dict["knob_type"] != "reserved":
          # skip this segment for reserved space
          print("Creating non reserved knob...")
          data_dict["can_delete"] = True
          data_dict["current_value"] = data_dict["value"]
          data_dict["offset"] = get_integer_value(self.database[nvar_key]["next_offset"])
          self.database[nvar_key].setdefault("knobs", {})[unique_id] = data_dict
          self.database[nvar_key]["next_offset"] = self.get_next_offset(nvar_key, data_dict["size"])
          extra_details = self.database[nvar_key]["knobs"][unique_id]
        else:
          extra_details = self.database.get(nvar_key, {}).get("knobs", {})
        print(self.get_free_space(nvar_key))
        return {"status": "success", "message": "Knob created successfully", "extra_details": extra_details}
    else:
      err_message = "Nvar Key: {} does not exist".format(nvar_key)
      return {"status": "error", "message": err_message}

  def search_knob(self, nvar_key, unique_id):
    search_result = self.database.get(nvar_key, {}).setdefault("knobs", {}).get(unique_id, None)
    if search_result is not None:
      result = {"status": "success", "message": "", "extra_details": search_result}
    else:
      result = {"status": "error", "message": "Could not find Knob with nvar_key: {} and knob id: {}".format(nvar_key, unique_id)}
    return result

  def edit_knob(self, nvar_key, unique_id, new_value):
    if self.database[nvar_key]["knobs"][unique_id] is None:
      result = {"status": "error", "message": "Could not find Knob with nvar_key: {} and knob id: {}".format(nvar_key, unique_id)}
    else:
      self.database[nvar_key]["knobs"][unique_id]["current_value"] = new_value
      updated_result = self.database[nvar_key]["knobs"][unique_id]
      updated_result["current_value"] = new_value
      self.database[nvar_key]["knobs"][unique_id] = updated_result
      result = {"status": "success", "message": "", "extra_details": updated_result}
    return result

  def realign_offset(self, nvar_key):
    """Re-align any offset if they are deleted within the session

    :param nvar_key:
    :return:
    """
    offset = 0
    for key, value in self.database[nvar_key]["knobs"].items():
      value["offset"] = offset
      offset += get_integer_value(value["size"])
    self.database[nvar_key]["next_offset"] = offset

  def delete_knob(self, nvar_key, unique_id):
    popped = None
    if nvar_key in self.database:
      popped = self.database[nvar_key]["knobs"].pop(unique_id, None)
    if popped is not None:
      self.realign_offset(nvar_key)
      self.database[nvar_key]["free_space"] = self.get_free_space(nvar_key)
      result = {"status": "success", "message": "Successfully deleted knob with nvar_key: {} and knob id: {}".format(nvar_key, unique_id),
                "extra_details": popped}
    else:
      result = {"status": "error", "message": "Could not delete Knob with nvar_key: {} and knob id: {}".format(nvar_key, unique_id)}
    return result


if __name__ == "__main__":
  pass
